import { EndOfLine, Position, Range, Selection, TextEditorRevealType, WorkspaceEdit } from './extHostTypes';
import { editor, Uri, Thenable } from "monaco-editor";
import { TextLine } from "./vscode-common";
export declare function setWordDefinitionFor(modeId: string, wordDefinition: RegExp | undefined): void;
export declare function getWordDefinitionFor(modeId: string): RegExp | undefined;
export declare class TextDocument {
    readonly uri: Uri;
    readonly version: number;
    readonly model: editor.ITextModel;
    private _textLines;
    constructor(model: editor.ITextModel);
    get eol(): EndOfLine;
    get fileName(): string;
    get isClosed(): boolean;
    get isDirty(): boolean;
    get isUntitled(): boolean;
    readonly languageId: string;
    get lineCount(): number;
    private get _lines();
    getText(range?: Range): string;
    lineAt(lineOrPosition: number | Position): TextLine;
    offsetAt(position: Position): number;
    positionAt(offset: number): Position;
    save(): Thenable<boolean>;
    validateRange(range: Range): Range;
    validatePosition(position: Position): Position;
    getWordRangeAtPosition(_position: Position, regexp?: RegExp): Range | undefined;
}
export declare class TextEditor {
    readonly editor: editor.IStandaloneCodeEditor;
    private _disposed;
    get languageId(): string;
    constructor(editor: editor.IStandaloneCodeEditor);
    get document(): TextDocument;
    get selection(): Selection;
    set selection(value: Selection);
    get selections(): Selection[];
    set selections(value: Selection[]);
    get visibleRanges(): Range[];
    edit(callback: (edit: TextEditorEdit) => void, options?: {
        undoStopBefore: boolean;
        undoStopAfter: boolean;
    }): Promise<void>;
    private _applyEdit;
    revealRange(range: Range, revealType?: TextEditorRevealType): void;
    applyEdit(edit: WorkspaceEdit, newSelections?: Selection[]): Thenable<void>;
    addAction(param: {
        contextMenuOrder: number;
        keybindingContext: string;
        run(editor: editor.ICodeEditor): (void | Promise<void>);
        id: string;
        label: string;
        precondition: string;
        contextMenuGroupId: string;
        keybindings: number[];
    }): void;
    executeCommand(commandId: string, ...rest: any[]): Promise<void>;
    getConfiguration(configurationId: string): UndefinedConfiguration;
}
declare class UndefinedConfiguration {
    get<T>(_: string): T;
}
export interface ITextEditOperation {
    range: Range;
    text: string | null;
    forceMoveMarkers: boolean;
}
export interface IEditData {
    documentVersionId: number;
    edits: ITextEditOperation[];
    setEndOfLine: EndOfLine | undefined;
    undoStopBefore: boolean;
    undoStopAfter: boolean;
}
export declare class TextEditorEdit {
    private readonly _document;
    private readonly _documentVersionId;
    private readonly _undoStopBefore;
    private readonly _undoStopAfter;
    private _collectedEdits;
    private _setEndOfLine;
    private _finalized;
    constructor(document: TextDocument, options: {
        undoStopBefore: boolean;
        undoStopAfter: boolean;
    });
    finalize(): IEditData;
    private _throwIfFinalized;
    replace(location: Position | Range | Selection, value: string): void;
    insert(location: Position, value: string): void;
    delete(location: Range | Selection): void;
    private _pushEdit;
    setEndOfLine(endOfLine: EndOfLine): void;
}
export {};
