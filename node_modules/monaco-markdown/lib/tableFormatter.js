'use strict'; // https://github.github.com/gfm/#tables-extension-

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.activateTableFormatter = activateTableFormatter;
exports.deactivate = deactivate;

var _monacoEditor = require("monaco-editor");

var _vscodeMonaco = require("./vscode-monaco");

var _extHostTypes = require("./extHostTypes");

var TypeConverters = _interopRequireWildcard(require("./vscode-converters"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function activateTableFormatter(editor) {
  _monacoEditor.languages.registerDocumentFormattingEditProvider(editor.languageId, new MarkdownDocumentFormatter());
}

function deactivate() {}

var MarkdownDocumentFormatter = /*#__PURE__*/function () {
  function MarkdownDocumentFormatter() {
    _classCallCheck(this, MarkdownDocumentFormatter);
  }

  _createClass(MarkdownDocumentFormatter, [{
    key: "provideDocumentFormattingEdits",
    value: function provideDocumentFormattingEdits(model, options, _) {
      var _this = this;

      var edits = [];
      var document = new _vscodeMonaco.TextDocument(model);
      var tables = this.detectTables(document.getText());

      if (tables !== null) {
        tables.forEach(function (table) {
          edits.push({
            range: TypeConverters.Range.from(_this.getRange(document, table)),
            text: _this.formatTable(table, document, options)
          });
        });
        return edits;
      } else {
        return [];
      }
    }
  }, {
    key: "detectTables",
    value: function detectTables(text) {
      var lineBreak = '\\r?\\n';
      var contentLine = '\\|?.*\\|.*\\|?';
      var hyphenLine = '[ \\t]*\\|?( *:?-+:? *\\|)+( *:?-+:? *\\|?)[ \\t]*';
      var tableRegex = new RegExp(contentLine + lineBreak + hyphenLine + '(?:' + lineBreak + contentLine + ')*', 'g');
      return text.match(tableRegex);
    }
  }, {
    key: "getRange",
    value: function getRange(document, text) {
      var documentText = document.getText();
      var start = document.positionAt(documentText.indexOf(text));
      var end = document.positionAt(documentText.indexOf(text) + text.length);
      return new _extHostTypes.Range(start, end);
    }
    /**
     * Return the indentation of a table as a string of spaces by reading it from the first line.
     * In case of `markdown.extension.table.normalizeIndentation` is `enabled` it is rounded to the closest multiple of
     * the configured `tabSize`.
     */

  }, {
    key: "getTableIndentation",
    value: function getTableIndentation(text, options) {
      // let doNormalize = workspace.getConfiguration('markdown.extension.tableFormatter').get<boolean>('normalizeIndentation');
      var doNormalize = true;
      var indentRegex = new RegExp(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/);
      var match = text.match(indentRegex);
      var spacesInFirstLine = match[1].length;
      var tabStops = Math.round(spacesInFirstLine / options.tabSize);
      var spaces = doNormalize ? " ".repeat(options.tabSize * tabStops) : " ".repeat(spacesInFirstLine);
      return spaces;
    }
  }, {
    key: "formatTable",
    value: function formatTable(text, doc, options) {
      var _this2 = this;

      var indentation = this.getTableIndentation(text, options);
      var rows = [];
      var rowsNoIndentPattern = new RegExp(/^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*((?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)$/gm);
      var match = null;

      while ((match = rowsNoIndentPattern.exec(text)) !== null) {
        rows.push(match[1].trim());
      } // Desired width of each column


      var colWidth = []; // Alignment of each column        

      var colAlign = []; // Regex to extract cell content.
      // Known issue: `\\|` is not correctly parsed as a valid delimiter

      var fieldRegExp = new RegExp(/(?:((?:\\\||`(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*?`|(?:(?!\|)[\s\S]))*)\|)/g);
      var cjkRegex = /[\u3000-\u9fff\uff01-\uff60]/g;
      var lines = rows.map(function (row, num) {
        // Normalize
        if (row.startsWith('|')) {
          row = row.slice(1);
        }

        if (!row.endsWith('|')) {
          row = row + '|';
        }

        var field = null;
        var values = [];
        var i = 0;

        while ((field = fieldRegExp.exec(row)) !== null) {
          var cell = field[1].trim();
          values.push(cell); // Ignore length of dash-line to enable width reduction

          if (num != 1) {
            // Treat CJK characters as 2 English ones because of Unicode stuff
            var length = cjkRegex.test(cell) ? cell.length + cell.match(cjkRegex).length : cell.length;
            colWidth[i] = colWidth[i] > length ? colWidth[i] : length;
          }

          i++;
        }

        return values;
      }); // Normalize the num of hyphen, use Math.max to determine minimum length based on dash-line format

      lines[1] = lines[1].map(function (cell, i) {
        if (/:-+:/.test(cell)) {
          //:---:
          colWidth[i] = Math.max(colWidth[i], 5);
          colAlign[i] = 'c';
          return ':' + '-'.repeat(colWidth[i] - 2) + ':';
        } else if (/:-+/.test(cell)) {
          //:---
          colWidth[i] = Math.max(colWidth[i], 4);
          colAlign[i] = 'l';
          return ':' + '-'.repeat(colWidth[i] - 1);
        } else if (/-+:/.test(cell)) {
          //---:
          colWidth[i] = Math.max(colWidth[i], 4);
          colAlign[i] = 'r';
          return '-'.repeat(colWidth[i] - 1) + ':';
        } else if (/-+/.test(cell)) {
          //---
          colWidth[i] = Math.max(colWidth[i], 3);
          colAlign[i] = 'l';
          return '-'.repeat(colWidth[i]);
        } else {
          colAlign[i] = 'l';
        }
      });
      return lines.map(function (row) {
        var cells = row.map(function (cell, i) {
          var cellLength = colWidth[i];

          if (cjkRegex.test(cell)) {
            cellLength -= cell.match(cjkRegex).length;
          } //return (cell + ' '.repeat(cellLength)).slice(0, cellLength);


          return _this2.alignText(cell, colAlign[i], cellLength);
        });
        return indentation + '| ' + cells.join(' | ') + ' |';
      }).join(doc.eol === _extHostTypes.EndOfLine.LF ? '\n' : '\r\n');
    }
  }, {
    key: "alignText",
    value: function alignText(text, align, length) {
      if (align === 'c' && length > text.length) {
        return (' '.repeat(Math.floor((length - text.length) / 2)) + text + ' '.repeat(length)).slice(0, length);
      } else if (align === 'r') {
        return (' '.repeat(length) + text).slice(-length);
      } else {
        return (text + ' '.repeat(length)).slice(0, length);
      }
    }
  }]);

  return MarkdownDocumentFormatter;
}();