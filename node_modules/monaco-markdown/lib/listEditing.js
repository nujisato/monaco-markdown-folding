'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.activateListEditing = activateListEditing;
exports.deactivate = deactivate;
exports.fixMarker = fixMarker;

var _util = require("./util");

var _monacoEditor = require("monaco-editor");

var _extHostTypes = require("./extHostTypes");

var _formatting = require("./formatting");

function onShiftTabKey(editor) {
  onTabKey(editor, 'shift');
}

function activateListEditing(editor) {
  var editorContext = "editorTextFocus && !editorReadonly && !suggestWidgetVisible";
  (0, _formatting.addKeybinding)(editor, "onEnterKey", onEnterKey, [_monacoEditor.KeyCode.Enter], "", editorContext, null);
  (0, _formatting.addKeybinding)(editor, "onCtrlEnterKey", onCtrlEnterKey, [_monacoEditor.KeyCode.Enter | _monacoEditor.KeyMod.CtrlCmd], "", editorContext, null);
  (0, _formatting.addKeybinding)(editor, "onShiftEnterKey", onShiftEnterKey, [_monacoEditor.KeyCode.Enter | _monacoEditor.KeyMod.Shift], "", editorContext, null);
  (0, _formatting.addKeybinding)(editor, "onTabKey", onTabKey, [_monacoEditor.KeyCode.Tab], "", editorContext, null);
  (0, _formatting.addKeybinding)(editor, "onShiftTabKey", onShiftTabKey, [_monacoEditor.KeyCode.Tab | _monacoEditor.KeyMod.Shift], "", editorContext, null);
  (0, _formatting.addKeybinding)(editor, "onBackspaceKey", onBackspaceKey, [_monacoEditor.KeyCode.Backspace], "", editorContext, null); //
  // context.subscriptions.push(
  //     commands.registerCommand('markdown.extension.checkTaskList', checkTaskList),
  //     commands.registerCommand('markdown.extension.onMoveLineDown', onMoveLineDown),
  //     commands.registerCommand('markdown.extension.onMoveLineUp', onMoveLineUp),
  //     commands.registerCommand('markdown.extension.onCopyLineDown', onCopyLineDown),
  //     commands.registerCommand('markdown.extension.onCopyLineUp', onCopyLineUp),
  //     commands.registerCommand('markdown.extension.onIndentLines', onIndentLines),
  //     commands.registerCommand('markdown.extension.onOutdentLines', onOutdentLines)
  // );
}

function onShiftEnterKey(editor) {
  onEnterKey(editor, 'shift');
}

function onCtrlEnterKey(editor) {
  onEnterKey(editor, 'ctrl');
}

function onEnterKey(editor, modifiers) {
  var cursorPos = editor.selection.active;
  var line = editor.document.lineAt(cursorPos.line);
  var textBeforeCursor = line.text.substr(0, cursorPos.character);
  var textAfterCursor = line.text.substr(cursorPos.character);
  var lineBreakPos = cursorPos;

  if (modifiers == 'ctrl') {
    lineBreakPos = line.range.end;
  }

  if (modifiers == 'shift' || (0, _util.isInFencedCodeBlock)(editor.document, cursorPos.line)) {
    return asNormal(editor, 'enter', modifiers);
  } // If it's an empty list item, remove it


  if (/^(>|([-+*]|[0-9]+[.)])( +\[[ x]\])?)$/.test(textBeforeCursor.trim()) && textAfterCursor.trim().length == 0) {
    return editor.edit(function (editBuilder) {
      editBuilder.delete(line.range);
      editBuilder.insert(line.range.end, '\n');
    }).then(function () {
      editor.revealRange(editor.selection);
    }).then(function () {
      return fixMarker(editor, findNextMarkerLineNumber(editor));
    });
  }

  var matches;

  if (/^> /.test(textBeforeCursor)) {
    // Quote block
    return editor.edit(function (editBuilder) {
      editBuilder.insert(lineBreakPos, "\n> ");
    }).then(function () {
      // Fix cursor position
      if (modifiers == 'ctrl' && !cursorPos.isEqual(lineBreakPos)) {
        var newCursorPos = cursorPos.with(line.lineNumber + 1, 2);
        editor.selection = new _extHostTypes.Selection(newCursorPos, newCursorPos);
      }
    }).then(function () {
      editor.revealRange(editor.selection);
    });
  } else if ((matches = /^(\s*[-+*] +(\[[ x]\] +)?)/.exec(textBeforeCursor)) !== null) {
    // Unordered list
    return editor.edit(function (editBuilder) {
      editBuilder.insert(lineBreakPos, "\n".concat(matches[1].replace('[x]', '[ ]')));
    }).then(function () {
      // Fix cursor position
      if (modifiers == 'ctrl' && !cursorPos.isEqual(lineBreakPos)) {
        var newCursorPos = cursorPos.with(line.lineNumber + 1, matches[1].length);
        editor.selection = new _extHostTypes.Selection(newCursorPos, newCursorPos);
      }
    }).then(function () {
      editor.revealRange(editor.selection);
    });
  } else if ((matches = /^(\s*)([0-9]+)([.)])( +)((\[[ x]\] +)?)/.exec(textBeforeCursor)) !== null) {
    // Ordered list
    var config = editor.getConfiguration('markdown.extension.orderedList').get('marker');
    var marker = '1';
    var leadingSpace = matches[1];
    var previousMarker = matches[2];
    var delimiter = matches[3];
    var trailingSpace = matches[4];
    var gfmCheckbox = matches[5].replace('[x]', '[ ]');
    var textIndent = (previousMarker + delimiter + trailingSpace).length;

    if (config == 'ordered') {
      marker = String(Number(previousMarker) + 1);
    } // Add enough trailing spaces so that the text is aligned with the previous list item, but always keep at least one space


    trailingSpace = " ".repeat(Math.max(1, textIndent - (marker + delimiter).length));
    var toBeAdded = leadingSpace + marker + delimiter + trailingSpace + gfmCheckbox;
    return editor.edit(function (editBuilder) {
      editBuilder.insert(lineBreakPos, "\n".concat(toBeAdded));
    }, {
      undoStopBefore: true,
      undoStopAfter: false
    }).then(function () {
      // Fix cursor position
      if (modifiers == 'ctrl' && !cursorPos.isEqual(lineBreakPos)) {
        var newCursorPos = cursorPos.with(line.lineNumber + 1, toBeAdded.length);
        editor.selection = new _extHostTypes.Selection(newCursorPos, newCursorPos);
      }
    }).then(function () {
      return fixMarker(editor);
    }).then(function () {
      editor.revealRange(editor.selection);
    });
  } else {
    return asNormal(editor, 'enter', modifiers);
  }
}

function onTabKey(editor, modifiers) {
  var cursorPos = editor.selection.start;
  var lineText = editor.document.lineAt(cursorPos.line).text;

  if ((0, _util.isInFencedCodeBlock)(editor.document, cursorPos.line)) {
    return asNormal(editor, 'tab', modifiers);
  }

  var match = /^\s*([-+*]|[0-9]+[.)]) +(\[[ x]\] +)?/.exec(lineText);

  if (match && (modifiers === 'shift' || !editor.selection.isEmpty || editor.selection.isEmpty && cursorPos.character <= match[0].length)) {
    if (modifiers === 'shift') {
      return outdent(editor).then(function () {
        return fixMarker(editor);
      });
    } else {
      return indent(editor).then(function () {
        return fixMarker(editor);
      });
    }
  } else {
    return asNormal(editor, 'tab', modifiers);
  }
}

function onBackspaceKey(editor) {
  var cursor = editor.selection.active;
  var document = editor.document;
  var textBeforeCursor = document.lineAt(cursor.line).text.substr(0, cursor.character);

  if ((0, _util.isInFencedCodeBlock)(document, cursor.line)) {
    return asNormal(editor, 'backspace');
  }

  if (!editor.selection.isEmpty) {
    return asNormal(editor, 'backspace').then(function () {
      return fixMarker(editor, findNextMarkerLineNumber(editor));
    });
  } else if (/^\s+([-+*]|[0-9]+[.)]) $/.test(textBeforeCursor)) {
    // e.g. textBeforeCursor === `  - `, `   1. `
    return outdent(editor).then(function () {
      return fixMarker(editor);
    });
  } else if (/^([-+*]|[0-9]+[.)]) $/.test(textBeforeCursor)) {
    // e.g. textBeforeCursor === `- `, `1. `
    return editor.edit(function (editBuilder) {
      editBuilder.replace(new _extHostTypes.Range(cursor.with({
        character: 0
      }), cursor), ' '.repeat(textBeforeCursor.length));
    }).then(function () {
      return fixMarker(editor, findNextMarkerLineNumber(editor));
    });
  } else if (/^\s*([-+*]|[0-9]+[.)]) +(\[[ x]\] )$/.test(textBeforeCursor)) {
    // e.g. textBeforeCursor === `- [ ]`, `1. [x]`, `  - [x]`
    return deleteRange(editor, new _extHostTypes.Range(cursor.with({
      character: textBeforeCursor.length - 4
    }), cursor)).then(function () {
      return fixMarker(editor, findNextMarkerLineNumber(editor));
    });
  } else {
    return asNormal(editor, 'backspace');
  }
}

function asNormal(editor, key, modifiers) {
  switch (key) {
    case 'enter':
      if (modifiers === 'ctrl') {
        return editor.executeCommand('editor.action.insertLineAfter');
      } else {
        return editor.executeCommand('type', {
          source: 'keyboard',
          text: '\n'
        });
      }

    case 'tab':
      if (editor.getConfiguration('emmet').get('triggerExpansionOnTab')) {
        return editor.executeCommand('editor.emmet.action.expandAbbreviation');
      } else if (modifiers === 'shift') {
        return editor.executeCommand('editor.action.outdentLines');
      } else {
        return editor.executeCommand('tab');
      }

    case 'backspace':
      return editor.executeCommand('deleteLeft');
  }
}
/**
 * If
 *
 * 1. it is not the first line
 * 2. there is a Markdown list item before this line
 *
 * then indent the current line to align with the previous list item.
 */


function indent(editor) {
  if (editor.getConfiguration("markdown.extension.list").get("indentationSize") === "adaptive") {
    try {
      var selection = editor.selection;
      var indentationSize = tryDetermineIndentationSize(editor, selection.start.line, editor.document.lineAt(selection.start.line).firstNonWhitespaceCharacterIndex);
      var edit = new _extHostTypes.WorkspaceEdit();

      for (var i = selection.start.line; i <= selection.end.line; i++) {
        if (i === selection.end.line && !selection.isEmpty && selection.end.character === 0) {
          break;
        }

        if (editor.document.lineAt(i).text.length !== 0) {
          edit.insert(editor.document.uri, new _extHostTypes.Position(i, 0), ' '.repeat(indentationSize));
        }
      }

      return editor.applyEdit(edit);
    } catch (error) {}
  }

  return editor.executeCommand('editor.action.indentLines');
}
/**
 * Similar to `indent`-function
 */


function outdent(editor) {
  if (editor.getConfiguration("markdown.extension.list").get("indentationSize") === "adaptive") {
    try {
      var selection = editor.selection;
      var indentationSize = tryDetermineIndentationSize(editor, selection.start.line, editor.document.lineAt(selection.start.line).firstNonWhitespaceCharacterIndex);
      var edit = new _extHostTypes.WorkspaceEdit();

      for (var i = selection.start.line; i <= selection.end.line; i++) {
        if (i === selection.end.line && !selection.isEmpty && selection.end.character === 0) {
          break;
        }

        var lineText = editor.document.lineAt(i).text;
        var maxOutdentSize = void 0;

        if (lineText.trim().length === 0) {
          maxOutdentSize = lineText.length;
        } else {
          maxOutdentSize = editor.document.lineAt(i).firstNonWhitespaceCharacterIndex;
        }

        if (maxOutdentSize > 0) {
          edit.delete(editor.document.uri, new _extHostTypes.Range(i, 0, i, Math.min(indentationSize, maxOutdentSize)));
        }
      }

      return editor.applyEdit(edit);
    } catch (error) {}
  }

  return editor.executeCommand('editor.action.outdentLines');
}

function tryDetermineIndentationSize(editor, line, currentIndentation) {
  while (--line >= 0) {
    var lineText = editor.document.lineAt(line).text;
    var matches = void 0;

    if ((matches = /^(\s*)(([-+*]|[0-9]+[.)]) +)(\[[ x]\] +)?/.exec(lineText)) !== null) {
      if (matches[1].length <= currentIndentation) {
        return matches[2].length;
      }
    }
  }

  throw "No previous Markdown list item";
}
/**
 * Returns the line number of the next ordered list item starting either from
 * the specified line or the beginning of the current selection.
 */


function findNextMarkerLineNumber(editor, line) {
  if (line === undefined) {
    // Use start.line instead of active.line so that we can find the first
    // marker following either the cursor or the entire selected range
    line = editor.selection.start.line;
  }

  while (line < editor.document.lineCount) {
    var lineText = editor.document.lineAt(line).text;

    if (/^\s*[0-9]+[.)] +/.exec(lineText) !== null) {
      return line;
    }

    line++;
  }

  return undefined;
}
/**
 * Looks for the previous ordered list marker at the same indentation level
 * and returns the marker number that should follow it.
 *
 * @returns the fixed marker number
 */


function lookUpwardForMarker(editor, line, currentIndentation) {
  while (--line >= 0) {
    var lineText = editor.document.lineAt(line).text;
    var matches = void 0;

    if ((matches = /^(\s*)(([0-9]+)[.)] +)/.exec(lineText)) !== null) {
      var leadingSpace = matches[1];
      var marker = matches[3];

      if (leadingSpace.length === currentIndentation) {
        return Number(marker) + 1;
      } else if (!leadingSpace.includes('\t') && leadingSpace.length + matches[2].length <= currentIndentation || leadingSpace.includes('\t') && leadingSpace.length + 1 <= currentIndentation) {
        return 1;
      }
    } else if ((matches = /^(\s*)\S/.exec(lineText)) !== null) {
      if (matches[1].length <= currentIndentation) {
        break;
      }
    }
  }

  return 1;
}
/**
 * Fix ordered list marker *iteratively* starting from current line
 */


function fixMarker(editor, line) {
  // if (!workspace.getConfiguration('markdown.extension.orderedList').get<boolean>('autoRenumber')) return;
  // if (workspace.getConfiguration('markdown.extension.orderedList').get<string>('marker') == 'one') return;
  if (line === undefined) {
    // Use either the first line containing an ordered list marker within the selection or the active line
    line = findNextMarkerLineNumber(editor);

    if (line === undefined || line > editor.selection.end.line) {
      line = editor.selection.active.line;
    }
  }

  if (line < 0 || editor.document.lineCount <= line) {
    return;
  }

  var currentLineText = editor.document.lineAt(line).text;
  var matches;

  if ((matches = /^(\s*)([0-9]+)([.)])( +)/.exec(currentLineText)) !== null) {
    // ordered list
    var leadingSpace = matches[1];
    var marker = matches[2];
    var delimiter = matches[3];
    var trailingSpace = matches[4];
    var fixedMarker = lookUpwardForMarker(editor, line, leadingSpace.length);
    var listIndent = marker.length + delimiter.length + trailingSpace.length;
    var fixedMarkerString = String(fixedMarker);
    return editor.edit(function (editBuilder) {
      if (marker === fixedMarkerString) {
        return;
      } // Add enough trailing spaces so that the text is still aligned at the same indentation level as it was previously, but always keep at least one space


      fixedMarkerString += delimiter + " ".repeat(Math.max(1, listIndent - (fixedMarkerString + delimiter).length));
      editBuilder.replace(new _extHostTypes.Range(line, leadingSpace.length, line, leadingSpace.length + listIndent), fixedMarkerString);
    }, {
      undoStopBefore: false,
      undoStopAfter: false
    }).then(function () {
      var nextLine = line + 1;
      var indentString = " ".repeat(listIndent);

      while (editor.document.lineCount > nextLine) {
        var nextLineText = editor.document.lineAt(nextLine).text;

        if (/^\s*[0-9]+[.)] +/.test(nextLineText)) {
          return fixMarker(editor, nextLine);
        } else if (/^\s*$/.test(nextLineText)) {
          nextLine++;
        } else if (listIndent <= 4 && !nextLineText.startsWith(indentString)) {
          return;
        } else {
          nextLine++;
        }
      }
    });
  }
}

function deleteRange(editor, range) {
  return editor.edit(function (editBuilder) {
    editBuilder.delete(range);
  }, // We will enable undoStop after fixing markers
  {
    undoStopBefore: true,
    undoStopAfter: false
  });
} // function checkTaskList(editor: TextEditor) {
//     let cursorPos = editor.selection.active;
//     let line = editor.document.lineAt(cursorPos.line).text;
//
//     let matches: RegExpExecArray;
//     if (matches = /^(\s*([-+*]|[0-9]+[.)]) +\[) \]/.exec(line)) {
//         return editor.edit((editBuilder:TextEditorEdit) => {
//             editBuilder.replace(new Range(cursorPos.with({ character: matches[1].length }), cursorPos.with({ character: matches[1].length + 1 })), 'x');
//         });
//     } else if (matches = /^(\s*([-+*]|[0-9]+[.)]) +\[)x\]/.exec(line)) {
//         return editor.edit((editBuilder:TextEditorEdit) => {
//             editBuilder.replace(new Range(cursorPos.with({ character: matches[1].length }), cursorPos.with({ character: matches[1].length + 1 })), ' ');
//         });
//     }
// }
// function onMoveLineUp() {
//     return commands.executeCommand('editor.action.moveLinesUpAction')
//         .then(() => fixMarker());
// }
//
// function onMoveLineDown() {
//     return commands.executeCommand('editor.action.moveLinesDownAction')
//         .then(() => fixMarker(findNextMarkerLineNumber(window.activeTextEditor.selection.start.line - 1)));
// }
//
// function onCopyLineUp() {
//     return commands.executeCommand('editor.action.copyLinesUpAction')
//         .then(() => fixMarker());
// }
//
// function onCopyLineDown() {
//     return commands.executeCommand('editor.action.copyLinesDownAction')
//         .then(() => fixMarker());
// }
//
// function onIndentLines() {
//     return indent().then(() => fixMarker());
// }
//
// function onOutdentLines() {
//     return outdent().then(() => fixMarker());
// }


function deactivate() {}