'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.activateFormatting = activateFormatting;
exports.addKeybinding = addKeybinding;
exports.isSingleLink = isSingleLink;

var _monacoEditor = require("monaco-editor");

var _listEditing = require("./listEditing");

var _extHostTypes = require("./extHostTypes");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function addKeybinding(editor, name, fun, keybindings, label, context) {
  var contextMenuGroupId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "markdown.extension.editing";
  editor.addAction({
    contextMenuGroupId: contextMenuGroupId,
    contextMenuOrder: 0,
    id: "markdown.extension.editing." + name,
    keybindingContext: context,
    keybindings: keybindings,
    label: label,
    precondition: "",
    run: function run(_) {
      fun(editor);
      return undefined;
    }
  });
}

function activateFormatting(editor) {
  addKeybinding(editor, "toggleBold", toggleBold, [_monacoEditor.KeyMod.CtrlCmd | _monacoEditor.KeyCode.KeyB], "Toggle bold");
  addKeybinding(editor, "toggleItalic", toggleItalic, [_monacoEditor.KeyMod.CtrlCmd | _monacoEditor.KeyCode.KeyI], "Toggle italic");
  addKeybinding(editor, "toggleCodeSpan", toggleCodeSpan, [_monacoEditor.KeyMod.CtrlCmd | _monacoEditor.KeyCode.Backquote], "Toggle code span");
  addKeybinding(editor, "toggleStrikethrough", toggleStrikethrough, [_monacoEditor.KeyMod.Alt | _monacoEditor.KeyCode.KeyS], "Toggle strikethrough");
  addKeybinding(editor, "toggleMath", toggleMath, [_monacoEditor.KeyMod.CtrlCmd | _monacoEditor.KeyCode.KeyM], "Toggle math");
  addKeybinding(editor, "toggleMathReverse", toggleMathReverse, [_monacoEditor.KeyMod.CtrlCmd | _monacoEditor.KeyMod.Shift | _monacoEditor.KeyCode.KeyM], "Toggle math reverse");
  addKeybinding(editor, "toggleHeadingUp", toggleHeadingUp, [_monacoEditor.KeyMod.WinCtrl | _monacoEditor.KeyMod.Shift | _monacoEditor.KeyCode.BracketLeft], "Heading up");
  addKeybinding(editor, "toggleHeadingDown", toggleHeadingDown, [_monacoEditor.KeyMod.WinCtrl | _monacoEditor.KeyMod.Shift | _monacoEditor.KeyCode.BracketRight], "Heading down");
  addKeybinding(editor, "toggleList", toggleList, [_monacoEditor.KeyMod.CtrlCmd | _monacoEditor.KeyCode.KeyL], "Toggle list"); // addKeybinding(editor, paste, [KeyMod.CtrlCmd | KeyCode.KEY_B], "Toggle bold");
}
/**
 * Here we store Regexp to check if the text is the single link.
 */


var singleLinkRegex = createLinkRegex(); // Return Promise because need to chain operations in unit tests

function toggleBold(editor) {
  return styleByWrapping(editor, '**');
}

function toggleItalic(editor) {
  // let indicator = workspace.getConfiguration('markdown.extension.italic').get<string>('indicator');
  return styleByWrapping(editor, '*');
}

function toggleCodeSpan(editor) {
  return styleByWrapping(editor, '`');
}

function toggleStrikethrough(editor) {
  return styleByWrapping(editor, '~~');
}

var maxHeading = '######';

function toggleHeadingUp(editor) {
  var lineIndex = editor.selection.active.line;
  var lineText = editor.document.lineAt(lineIndex).text;
  return editor.edit(function (editBuilder) {
    if (!lineText.startsWith('#')) {
      // Not a heading
      editBuilder.insert(new _extHostTypes.Position(lineIndex, 0), '# ');
    } else if (lineText.startsWith(maxHeading)) {
      // Reset heading at 6 level
      var deleteIndex = lineText.startsWith(maxHeading + ' ') ? maxHeading.length + 1 : maxHeading.length;
      editBuilder.delete(new _extHostTypes.Range(new _extHostTypes.Position(lineIndex, 0), new _extHostTypes.Position(lineIndex, deleteIndex)));
    } else {
      editBuilder.insert(new _extHostTypes.Position(lineIndex, 0), '#');
    }
  });
}

function toggleHeadingDown(editor) {
  var lineIndex = editor.selection.active.line;
  var lineText = editor.document.lineAt(lineIndex).text;
  editor.edit(function (editBuilder) {
    if (lineText.startsWith('# ')) {
      // Heading level 1
      editBuilder.delete(new _extHostTypes.Range(new _extHostTypes.Position(lineIndex, 0), new _extHostTypes.Position(lineIndex, 2)));
    } else if (lineText.startsWith('#')) {
      // Heading (but not level 1)
      editBuilder.delete(new _extHostTypes.Range(new _extHostTypes.Position(lineIndex, 0), new _extHostTypes.Position(lineIndex, 1)));
    } else {
      // No heading
      editBuilder.insert(new _extHostTypes.Position(lineIndex, 0), maxHeading + ' ');
    }
  });
}

var MathBlockState;

(function (MathBlockState) {
  MathBlockState[MathBlockState["NONE"] = 0] = "NONE";
  MathBlockState[MathBlockState["INLINE"] = 1] = "INLINE";
  MathBlockState[MathBlockState["SINGLE_DISPLAYED"] = 2] = "SINGLE_DISPLAYED";
  MathBlockState[MathBlockState["MULTI_DISPLAYED"] = 3] = "MULTI_DISPLAYED";
})(MathBlockState || (MathBlockState = {}));

function getMathState(editor, cursor) {
  if (getContext(editor, cursor, '$') === '$|$') {
    return MathBlockState.INLINE;
  } else if (getContext(editor, cursor, '$$ ', ' $$') === '$$ | $$') {
    return MathBlockState.SINGLE_DISPLAYED;
  } else if (editor.document.lineAt(cursor.line).text === '' && cursor.line > 0 && editor.document.lineAt(cursor.line - 1).text === '$$' && cursor.line < editor.document.lineCount - 1 && editor.document.lineAt(cursor.line + 1).text === '$$') {
    return MathBlockState.MULTI_DISPLAYED;
  } else {
    return MathBlockState.NONE;
  }
}
/**
 * Modify the document, change from `oldMathBlockState` to `newMathBlockState`.
 * @param editor
 * @param cursor
 * @param oldMathBlockState
 * @param newMathBlockState
 */


function setMathState(editor, cursor, oldMathBlockState, newMathBlockState) {
  // Step 1: Delete old math block.
  editor.edit(function (editBuilder) {
    var rangeToBeDeleted;

    switch (oldMathBlockState) {
      case MathBlockState.NONE:
        rangeToBeDeleted = new _extHostTypes.Range(cursor, cursor);
        break;

      case MathBlockState.INLINE:
        rangeToBeDeleted = new _extHostTypes.Range(new _extHostTypes.Position(cursor.line, cursor.character - 1), new _extHostTypes.Position(cursor.line, cursor.character + 1));
        break;

      case MathBlockState.SINGLE_DISPLAYED:
        rangeToBeDeleted = new _extHostTypes.Range(new _extHostTypes.Position(cursor.line, cursor.character - 3), new _extHostTypes.Position(cursor.line, cursor.character + 3));
        break;

      case MathBlockState.MULTI_DISPLAYED:
        rangeToBeDeleted = new _extHostTypes.Range(new _extHostTypes.Position(cursor.line - 1, 0), new _extHostTypes.Position(cursor.line + 1, 2));
        break;
    }

    editBuilder.delete(rangeToBeDeleted);
  }).then(function () {
    // Step 2: Insert new math block.
    editor.edit(function (editBuilder) {
      var newCursor = editor.selection.active;
      var stringToBeInserted;

      switch (newMathBlockState) {
        case MathBlockState.NONE:
          stringToBeInserted = '';
          break;

        case MathBlockState.INLINE:
          stringToBeInserted = '$$';
          break;

        case MathBlockState.SINGLE_DISPLAYED:
          stringToBeInserted = '$$  $$';
          break;

        case MathBlockState.MULTI_DISPLAYED:
          stringToBeInserted = '$$\n\n$$';
          break;
      }

      editBuilder.insert(newCursor, stringToBeInserted);
    }).then(function () {
      // Step 3: Move cursor to the middle.
      var newCursor = editor.selection.active;
      var newPosition;

      switch (newMathBlockState) {
        case MathBlockState.NONE:
          newPosition = newCursor;
          break;

        case MathBlockState.INLINE:
          newPosition = newCursor.with(newCursor.line, newCursor.character - 1);
          break;

        case MathBlockState.SINGLE_DISPLAYED:
          newPosition = newCursor.with(newCursor.line, newCursor.character - 3);
          break;

        case MathBlockState.MULTI_DISPLAYED:
          newPosition = newCursor.with(newCursor.line - 1, 0);
          break;
      }

      editor.selection = new _extHostTypes.Selection(newPosition, newPosition);
    });
  });
}

var transTable = [MathBlockState.NONE, MathBlockState.INLINE, MathBlockState.MULTI_DISPLAYED, MathBlockState.SINGLE_DISPLAYED];

var reverseTransTable = _construct(Array, transTable).reverse();

function toggleMath(editor) {
  _toggleMath(editor, transTable);
}

function toggleMathReverse(editor) {
  _toggleMath(editor, reverseTransTable);
}

function _toggleMath(editor, transTable) {
  if (!editor.selection.isEmpty) return;
  var cursor = editor.selection.active;
  var oldMathBlockState = getMathState(editor, cursor);
  var currentStateIndex = transTable.indexOf(oldMathBlockState);
  setMathState(editor, cursor, oldMathBlockState, transTable[(currentStateIndex + 1) % transTable.length]);
}

function toggleList(editor) {
  var doc = editor.document;
  var batchEdit = new _extHostTypes.WorkspaceEdit();
  editor.selections.forEach(function (selection) {
    if (selection.isEmpty) {
      toggleListSingleLine(doc, selection.active.line, batchEdit);
    } else {
      for (var i = selection.start.line; i <= selection.end.line; i++) {
        toggleListSingleLine(doc, i, batchEdit);
      }
    }
  });
  return editor.applyEdit(batchEdit, []).then(function () {
    return (0, _listEditing.fixMarker)(editor);
  });
}

function toggleListSingleLine(doc, line, wsEdit) {
  var lineText = doc.lineAt(line).text;
  var indentation = lineText.trim().length === 0 ? lineText.length : lineText.indexOf(lineText.trim());
  var lineTextContent = lineText.substr(indentation);

  if (lineTextContent.startsWith("- ")) {
    wsEdit.replace(doc.uri, new _extHostTypes.Range(line, indentation, line, indentation + 2), "* ");
  } else if (lineTextContent.startsWith("* ")) {
    wsEdit.replace(doc.uri, new _extHostTypes.Range(line, indentation, line, indentation + 2), "+ ");
  } else if (lineTextContent.startsWith("+ ")) {
    wsEdit.replace(doc.uri, new _extHostTypes.Range(line, indentation, line, indentation + 2), "1. ");
  } else if (/^\d\. /.test(lineTextContent)) {
    wsEdit.replace(doc.uri, new _extHostTypes.Range(line, indentation + 1, line, indentation + 2), ")");
  } else if (/^\d\) /.test(lineTextContent)) {
    wsEdit.delete(doc.uri, new _extHostTypes.Range(line, indentation, line, indentation + 3));
  } else {
    wsEdit.insert(doc.uri, new _extHostTypes.Position(line, indentation), "- ");
  }
} // async function paste() {
//     const editor = window.activeTextEditor;
//     const selection = editor.selection;
//     if (selection.isSingleLine && !isSingleLink(editor.document.getText(selection))) {
//         const text = await env.clipboard.readText();
//         if (isSingleLink(text)) {
//             return commands.executeCommand("editor.action.insertSnippet", { "snippet": `[$TM_SELECTED_TEXT$0](${text})` });
//         }
//     }
//     return commands.executeCommand("editor.action.clipboardPasteAction");
// }

/**
 * Creates Regexp to check if the text is a link (further detailes in the isSingleLink() documentation).
 *
 * @return Regexp
 */


function createLinkRegex() {
  // unicode letters range(must not be a raw string)
  var ul = "\\u00a1-\\uffff"; // IP patterns

  var ipv4_re = '(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}';
  var ipv6_re = '\\[[0-9a-f:\\.]+\\]'; // simple regex (in django it is validated additionally)
  // Host patterns

  var hostname_re = '[a-z' + ul + '0-9](?:[a-z' + ul + '0-9-]{0,61}[a-z' + ul + '0-9])?'; // Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1

  var domain_re = '(?:\\.(?!-)[a-z' + ul + '0-9-]{1,63})*';
  var tld_re = '' + '\\.' // dot
  + '(?!-)' // can't start with a dash
  + '(?:[a-z' + ul + '-]{2,63}' // domain label
  + '|xn--[a-z0-9]{1,59})' // or punycode label
  // + '(?<!-)'                            // can't end with a dash
  + '\\.?' // may have a trailing dot
  ;
  var host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)';
  var pattern = '' + '^(?:[a-z0-9\\.\\-\\+]*)://' // scheme is not validated (in django it is validated additionally)
  + '(?:[^\\s:@/]+(?::[^\\s:@/]*)?@)?' // user: pass authentication
  + '(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')' + '(?::\\d{2,5})?' // port
  + '(?:[/?#][^\\s]*)?' // resource path
  + '$' // end of string
  ;
  return new RegExp(pattern, 'i');
}
/**
 * Checks if the string is a link. The list of link examples you can see in the tests file
 * `test/linksRecognition.test.ts`. This code ported from django's
 * [URLValidator](https://github.com/django/django/blob/2.2b1/django/core/validators.py#L74) with some simplifyings.
 *
 * @param text string to check
 *
 * @return boolean
 */


function isSingleLink(text) {
  return singleLinkRegex.test(text);
}

function styleByWrapping(editor, startPattern, endPattern) {
  if (endPattern == undefined) {
    endPattern = startPattern;
  }

  var selections = editor.selections;
  var batchEdit = new _extHostTypes.WorkspaceEdit();
  var shifts = [];
  var newSelections = selections.slice();
  selections.forEach(function (selection, i) {
    var cursorPos = selection.active;
    var shift = shifts.map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          pos = _ref2[0],
          s = _ref2[1];

      return selection.start.line == pos.line && selection.start.character >= pos.character ? s : 0;
    }).reduce(function (a, b) {
      return a + b;
    }, 0);

    if (selection.isEmpty) {
      // No selected text
      if (startPattern !== '~~' && getContext(editor, cursorPos, startPattern) === "".concat(startPattern, "text|").concat(endPattern)) {
        // `**text|**` to `**text**|`
        var newCursorPos = cursorPos.with({
          character: cursorPos.character + shift + endPattern.length
        });
        newSelections[i] = new _extHostTypes.Selection(newCursorPos, newCursorPos);
        return;
      } else if (getContext(editor, cursorPos, startPattern) === "".concat(startPattern, "|").concat(endPattern)) {
        // `**|**` to `|`
        var start = cursorPos.with({
          character: cursorPos.character - startPattern.length
        });
        var end = cursorPos.with({
          character: cursorPos.character + endPattern.length
        });
        wrapRange(editor, batchEdit, shifts, newSelections, i, shift, cursorPos, new _extHostTypes.Range(start, end), false, startPattern);
      } else {
        // Select word under cursor
        var wordRange = editor.document.getWordRangeAtPosition(cursorPos);

        if (wordRange == undefined) {
          wordRange = selection;
        } // One special case: toggle strikethrough in task list


        var currentTextLine = editor.document.lineAt(cursorPos.line);

        if (startPattern === '~~' && /^\s*[\*\+\-] (\[[ x]\] )? */g.test(currentTextLine.text)) {
          wordRange = currentTextLine.range.with(new _extHostTypes.Position(cursorPos.line, currentTextLine.text.match(/^\s*[\*\+\-] (\[[ x]\] )? */g)[0].length));
        }

        wrapRange(editor, batchEdit, shifts, newSelections, i, shift, cursorPos, wordRange, false, startPattern);
      }
    } else {
      // Text selected
      wrapRange(editor, batchEdit, shifts, newSelections, i, shift, cursorPos, selection, true, startPattern);
    }
  });
  var hasSelection = editor.selection && !editor.selection.isEmpty;
  return editor.applyEdit(batchEdit, newSelections).then(function () {
    if (!hasSelection) {
      editor.selections = newSelections;
    }
  });
}
/**
 * Add or remove `startPattern`/`endPattern` according to the context
 * @param editor
 * @param options The undo/redo behavior
 * @param cursor cursor position
 * @param range range to be replaced
 * @param isSelected is this range selected
 * @param startPtn
 * @param endPtn
 */


function wrapRange(editor, wsEdit, shifts, newSelections, i, shift, cursor, range, isSelected, startPtn, endPtn) {
  if (endPtn == undefined) {
    endPtn = startPtn;
  }

  var text = editor.document.getText(range);
  var prevSelection = newSelections[i];
  var ptnLength = (startPtn + endPtn).length;
  var newCursorPos = cursor.with({
    character: cursor.character + shift
  });
  var newSelection;

  if (isWrapped(text, startPtn)) {
    // remove start/end patterns from range
    wsEdit.replace(editor.document.uri, range, text.substr(startPtn.length, text.length - ptnLength));
    shifts.push([range.end, -ptnLength]); // Fix cursor position

    if (!isSelected) {
      if (!range.isEmpty) {
        // means quick styling
        if (cursor.character == range.end.character) {
          newCursorPos = cursor.with({
            character: cursor.character + shift - ptnLength
          });
        } else {
          newCursorPos = cursor.with({
            character: cursor.character + shift - startPtn.length
          });
        }
      } else {
        // means `**|**` -> `|`
        newCursorPos = cursor.with({
          character: cursor.character + shift + startPtn.length
        });
      }

      newSelection = new _extHostTypes.Selection(newCursorPos, newCursorPos);
    } else {
      newSelection = new _extHostTypes.Selection(prevSelection.start.with({
        character: prevSelection.start.character + shift
      }), prevSelection.end.with({
        character: prevSelection.end.character + shift - ptnLength
      }));
    }
  } else {
    // add start/end patterns around range
    wsEdit.replace(editor.document.uri, range, startPtn + text + endPtn);
    shifts.push([range.end, ptnLength]); // Fix cursor position

    if (!isSelected) {
      if (!range.isEmpty) {
        // means quick styling
        if (cursor.character == range.end.character) {
          newCursorPos = cursor.with({
            character: cursor.character + shift + ptnLength
          });
        } else {
          newCursorPos = cursor.with({
            character: cursor.character + shift + startPtn.length
          });
        }
      } else {
        // means `|` -> `**|**`
        newCursorPos = cursor.with({
          character: cursor.character + shift + startPtn.length
        });
      }

      newSelection = new _extHostTypes.Selection(newCursorPos, newCursorPos);
    } else {
      newSelection = new _extHostTypes.Selection(prevSelection.start.with({
        character: prevSelection.start.character + shift
      }), prevSelection.end.with({
        character: prevSelection.end.character + shift + ptnLength
      }));
    }
  }

  newSelections[i] = newSelection;
}

function isWrapped(text, startPattern, endPattern) {
  if (endPattern == undefined) {
    endPattern = startPattern;
  }

  return text.startsWith(startPattern) && text.endsWith(endPattern);
}

function getContext(editor, cursorPos, startPattern, endPattern) {
  if (endPattern == undefined) {
    endPattern = startPattern;
  }

  var startPositionCharacter = cursorPos.character - startPattern.length;
  var endPositionCharacter = cursorPos.character + endPattern.length;

  if (startPositionCharacter < 0) {
    startPositionCharacter = 0;
  }

  var leftText = editor.document.getText(new _extHostTypes.Range(cursorPos.line, startPositionCharacter, cursorPos.line, cursorPos.character));
  var rightText = editor.document.getText(new _extHostTypes.Range(cursorPos.line, cursorPos.character, cursorPos.line, endPositionCharacter));

  if (rightText == endPattern) {
    if (leftText == startPattern) {
      return "".concat(startPattern, "|").concat(endPattern);
    } else {
      return "".concat(startPattern, "text|").concat(endPattern);
    }
  }

  return '|';
}