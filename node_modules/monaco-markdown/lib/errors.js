"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorHandler = void 0;
exports.canceled = canceled;
exports.disposed = disposed;
exports.errorHandler = void 0;
exports.getErrorMessage = getErrorMessage;
exports.illegalArgument = illegalArgument;
exports.illegalState = illegalState;
exports.isPromiseCanceledError = isPromiseCanceledError;
exports.onUnexpectedError = onUnexpectedError;
exports.onUnexpectedExternalError = onUnexpectedExternalError;
exports.readonly = readonly;
exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;
exports.transformErrorForSerialization = transformErrorForSerialization;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Avoid circular dependency on EventEmitter by implementing a subset of the interface.
var ErrorHandler = /*#__PURE__*/function () {
  function ErrorHandler() {
    _classCallCheck(this, ErrorHandler);

    this.listeners = [];

    this.unexpectedErrorHandler = function (e) {
      setTimeout(function () {
        if (e.stack) {
          throw new Error(e.message + '\n\n' + e.stack);
        }

        throw e;
      }, 0);
    };
  }

  _createClass(ErrorHandler, [{
    key: "addListener",
    value: function addListener(listener) {
      var _this = this;

      this.listeners.push(listener);
      return function () {
        _this._removeListener(listener);
      };
    }
  }, {
    key: "emit",
    value: function emit(e) {
      this.listeners.forEach(function (listener) {
        listener(e);
      });
    }
  }, {
    key: "_removeListener",
    value: function _removeListener(listener) {
      this.listeners.splice(this.listeners.indexOf(listener), 1);
    }
  }, {
    key: "setUnexpectedErrorHandler",
    value: function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
      this.unexpectedErrorHandler = newUnexpectedErrorHandler;
    }
  }, {
    key: "getUnexpectedErrorHandler",
    value: function getUnexpectedErrorHandler() {
      return this.unexpectedErrorHandler;
    }
  }, {
    key: "onUnexpectedError",
    value: function onUnexpectedError(e) {
      this.unexpectedErrorHandler(e);
      this.emit(e);
    } // For external errors, we don't want the listeners to be called

  }, {
    key: "onUnexpectedExternalError",
    value: function onUnexpectedExternalError(e) {
      this.unexpectedErrorHandler(e);
    }
  }]);

  return ErrorHandler;
}();

exports.ErrorHandler = ErrorHandler;
var errorHandler = new ErrorHandler();
exports.errorHandler = errorHandler;

function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
  errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
}

function onUnexpectedError(e) {
  // ignore errors from cancelled promises
  if (!isPromiseCanceledError(e)) {
    errorHandler.onUnexpectedError(e);
  }

  return undefined;
}

function onUnexpectedExternalError(e) {
  // ignore errors from cancelled promises
  if (!isPromiseCanceledError(e)) {
    errorHandler.onUnexpectedExternalError(e);
  }

  return undefined;
}

function transformErrorForSerialization(error) {
  if (error instanceof Error) {
    var name = error.name,
        message = error.message;
    var stack = error.stacktrace || error.stack;
    return {
      $isError: true,
      name: name,
      message: message,
      stack: stack
    };
  } // return as is


  return error;
} // see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces


var canceledName = 'Canceled';
/**
 * Checks if the given error is a promise in canceled state
 */

function isPromiseCanceledError(error) {
  return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
/**
 * Returns an error that signals cancellation.
 */


function canceled() {
  var error = new Error(canceledName);
  error.name = error.message;
  return error;
}

function illegalArgument(name) {
  if (name) {
    return new Error("Illegal argument: ".concat(name));
  } else {
    return new Error('Illegal argument');
  }
}

function illegalState(name) {
  if (name) {
    return new Error("Illegal state: ".concat(name));
  } else {
    return new Error('Illegal state');
  }
}

function readonly(name) {
  return name ? new Error("readonly property '".concat(name, " cannot be changed'")) : new Error('readonly property cannot be changed');
}

function disposed(what) {
  var result = new Error("".concat(what, " has been disposed"));
  result.name = 'DISPOSED';
  return result;
}

function getErrorMessage(err) {
  if (!err) {
    return 'Error';
  }

  if (err.message) {
    return err.message;
  }

  if (err.stack) {
    return err.stack.split('\n')[0];
  }

  return String(err);
}