"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextEditorEdit = exports.TextEditor = exports.TextDocument = void 0;
exports.getWordDefinitionFor = getWordDefinitionFor;
exports.setWordDefinitionFor = setWordDefinitionFor;

var _extHostTypes = require("./extHostTypes");

var _monacoEditor = require("monaco-editor");

var _vscodeUtils = require("./vscode-utils");

var _wordHelper = require("./wordHelper");

var TypeConverters = _interopRequireWildcard(require("./vscode-converters"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _modeId2WordDefinition = new Map();

function setWordDefinitionFor(modeId, wordDefinition) {
  _modeId2WordDefinition.set(modeId, wordDefinition);
}

function getWordDefinitionFor(modeId) {
  return _modeId2WordDefinition.get(modeId);
}

function revealRangeInEditor(_editor, range, revealType) {
  switch (revealType) {
    case _extHostTypes.TextEditorRevealType.Default:
    case undefined:
      _editor.revealRange(range, _monacoEditor.editor.ScrollType.Smooth);

      break;

    case _extHostTypes.TextEditorRevealType.InCenter:
      _editor.revealRangeInCenter(range, _monacoEditor.editor.ScrollType.Smooth);

      break;

    case _extHostTypes.TextEditorRevealType.InCenterIfOutsideViewport:
      _editor.revealRangeInCenterIfOutsideViewport(range, _monacoEditor.editor.ScrollType.Smooth);

      break;

    case _extHostTypes.TextEditorRevealType.AtTop:
      _editor.revealRangeAtTop(range, _monacoEditor.editor.ScrollType.Smooth);

      break;

    default:
      console.warn("Unknown revealType: ".concat(revealType));
      break;
  }
}

var TextDocument = /*#__PURE__*/function () {
  function TextDocument(model) {
    _classCallCheck(this, TextDocument);

    this._textLines = [];
    this.model = model;
    this.languageId = getLanguageId(model);
  }

  _createClass(TextDocument, [{
    key: "eol",
    get: function get() {
      switch (this.model.getEOL()) {
        case '\n':
          {
            return _extHostTypes.EndOfLine.LF;
          }

        case '\r\n':
          {
            return _extHostTypes.EndOfLine.CRLF;
          }

        default:
          {
            throw new Error("invalid argument");
          }
      }
    }
  }, {
    key: "fileName",
    get: function get() {
      return '';
    }
  }, {
    key: "isClosed",
    get: function get() {
      return false;
    }
  }, {
    key: "isDirty",
    get: function get() {
      return false;
    }
  }, {
    key: "isUntitled",
    get: function get() {
      return true;
    }
  }, {
    key: "lineCount",
    get: function get() {
      return this.model.getLineCount();
    }
  }, {
    key: "_lines",
    get: function get() {
      return this.model.getLinesContent();
    }
  }, {
    key: "getText",
    value: function getText(range) {
      if (!range) {
        return this.model.getValue();
      }

      return this.model.getValueInRange(TypeConverters.Range.from(range));
    }
  }, {
    key: "lineAt",
    value: function lineAt(lineOrPosition) {
      var line;

      if (lineOrPosition instanceof _extHostTypes.Position) {
        line = lineOrPosition.line;
      } else if (typeof lineOrPosition === 'number') {
        line = lineOrPosition;
      }

      if (typeof line !== 'number' || line < 0 || line >= this._lines.length) {
        throw new Error('Illegal value for `line`');
      }

      var result = this._textLines[line];

      if (!result || result.lineNumber !== line || result.text !== this._lines[line]) {
        var text = this._lines[line];
        var firstNonWhitespaceCharacterIndex = /^(\s*)/.exec(text)[1].length;
        var range = new _extHostTypes.Range(line, 0, line, text.length);
        var rangeIncludingLineBreak = line < this._lines.length - 1 ? new _extHostTypes.Range(line, 0, line + 1, 0) : range;
        result = Object.freeze({
          lineNumber: line,
          range: range,
          rangeIncludingLineBreak: rangeIncludingLineBreak,
          text: text,
          firstNonWhitespaceCharacterIndex: firstNonWhitespaceCharacterIndex,
          //TODO@api, rename to 'leadingWhitespaceLength'
          isEmptyOrWhitespace: firstNonWhitespaceCharacterIndex === text.length
        });
        this._textLines[line] = result;
      }

      return result;
    }
  }, {
    key: "offsetAt",
    value: function offsetAt(position) {
      return this.model.getOffsetAt(TypeConverters.Position.from(position));
    }
  }, {
    key: "positionAt",
    value: function positionAt(offset) {
      return TypeConverters.Position.to(this.model.getPositionAt(offset));
    }
  }, {
    key: "save",
    value: function save() {
      throw new Error("Not implemented");
    }
  }, {
    key: "validateRange",
    value: function validateRange(range) {
      if (!(range instanceof _extHostTypes.Range)) {
        throw new Error('Invalid argument');
      }

      var start = this.validatePosition(range.start);
      var end = this.validatePosition(range.end);

      if (start === range.start && end === range.end) {
        return range;
      }

      return new _extHostTypes.Range(start.line, start.character, end.line, end.character);
    }
  }, {
    key: "validatePosition",
    value: function validatePosition(position) {
      if (!(position instanceof _extHostTypes.Position)) {
        throw new Error('Invalid argument');
      }

      var line = position.line,
          character = position.character;
      var hasChanged = false;

      if (line < 0) {
        line = 0;
        character = 0;
        hasChanged = true;
      } else if (line >= this._lines.length) {
        line = this._lines.length - 1;
        character = this._lines[line].length;
        hasChanged = true;
      } else {
        var maxCharacter = this._lines[line].length;

        if (character < 0) {
          character = 0;
          hasChanged = true;
        } else if (character > maxCharacter) {
          character = maxCharacter;
          hasChanged = true;
        }
      }

      if (!hasChanged) {
        return position;
      }

      return new _extHostTypes.Position(line, character);
    }
  }, {
    key: "getWordRangeAtPosition",
    value: function getWordRangeAtPosition(_position, regexp) {
      var position = this.validatePosition(_position);

      if (!regexp) {
        // use default when custom-regexp isn't provided
        regexp = getWordDefinitionFor(this.languageId);
      } else if ((0, _vscodeUtils.regExpLeadsToEndlessLoop)(regexp)) {
        // use default when custom-regexp is bad
        console.warn("[getWordRangeAtPosition]: ignoring custom regexp '".concat(regexp.source, "' because it matches the empty string."));
        regexp = getWordDefinitionFor(this.languageId);
      }

      var wordAtText = (0, _wordHelper.getWordAtText)(position.character + 1, (0, _wordHelper.ensureValidWordDefinition)(regexp), this._lines[position.line], 0);

      if (wordAtText) {
        return new _extHostTypes.Range(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);
      }

      return undefined;
    }
  }]);

  return TextDocument;
}();

exports.TextDocument = TextDocument;

function getLanguageId(model) {
  // @ts-ignore
  return model.getLanguageId();
}

var TextEditor = /*#__PURE__*/function () {
  function TextEditor(editor) {
    _classCallCheck(this, TextEditor);

    _initialiseProps.call(this);

    this.editor = editor;
  }

  _createClass(TextEditor, [{
    key: "languageId",
    get: function get() {
      return getLanguageId(this.editor.getModel());
    }
  }, {
    key: "document",
    get: function get() {
      return new TextDocument(this.editor.getModel());
    }
  }, {
    key: "selection",
    get: function get() {
      return TypeConverters.Selection.to(this.editor.getSelection());
    },
    set: function set(value) {
      this.editor.setSelection(TypeConverters.Selection.from(value));
    }
  }, {
    key: "selections",
    get: function get() {
      return this.editor.getSelections().map(function (s) {
        return TypeConverters.Selection.to(s);
      });
    },
    set: function set(value) {
      this.editor.setSelections(value.map(function (s) {
        return TypeConverters.Selection.from(s);
      }));
    }
  }, {
    key: "visibleRanges",
    get: function get() {
      return this.editor.getVisibleRanges().map(function (r) {
        return TypeConverters.Range.to(r);
      });
    }
  }, {
    key: "edit",
    value: function edit(callback) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        undoStopBefore: true,
        undoStopAfter: true
      };

      if (this._disposed) {
        return Promise.reject(new Error('TextEditor#edit not possible on closed editors'));
      }

      var edit = new TextEditorEdit(this.document, options);
      callback(edit);
      return this._applyEdit(edit);
    }
  }, {
    key: "_applyEdit",
    value: function _applyEdit(editBuilder) {
      var editData = editBuilder.finalize(); // return when there is nothing to do

      if (editData.edits.length === 0 && !editData.setEndOfLine) {
        return Promise.resolve(null);
      } // check that the edits are not overlapping (i.e. illegal)


      var editRanges = editData.edits.map(function (edit) {
        return edit.range;
      }); // sort ascending (by end and then by start)

      editRanges.sort(function (a, b) {
        if (a.end.line === b.end.line) {
          if (a.end.character === b.end.character) {
            if (a.start.line === b.start.line) {
              return a.start.character - b.start.character;
            }

            return a.start.line - b.start.line;
          }

          return a.end.character - b.end.character;
        }

        return a.end.line - b.end.line;
      }); // check that no edits are overlapping

      for (var i = 0, count = editRanges.length - 1; i < count; i++) {
        var rangeEnd = editRanges[i].end;
        var nextRangeStart = editRanges[i + 1].start;

        if (nextRangeStart.isBefore(rangeEnd)) {
          // overlapping ranges
          return Promise.reject(new Error('Overlapping ranges are not allowed!'));
        }
      } // prepare data for serialization


      var edits = editData.edits.map(function (edit) {
        return {
          range: TypeConverters.Range.from(edit.range),
          text: edit.text,
          forceMoveMarkers: edit.forceMoveMarkers
        };
      });
      this.editor.getModel().pushEditOperations(this.editor.getSelections(), edits, function () {
        return [];
      });
      return Promise.resolve(null);
    } // insertSnippet(snippet: SnippetString, where?: Position | readonly Position[] | Range | readonly Range[], options: { undoStopBefore: boolean; undoStopAfter: boolean; } = {
    //     undoStopBefore: true,
    //     undoStopAfter: true
    // }): Promise<boolean> {}
    // hide(): void {
    //     throw new Error("Not implemented")
    // }
    // @ts-ignore
    // show(column?: ViewColumn): void {
    //     throw new Error("Not implemented")
    // }

  }, {
    key: "revealRange",
    value: function revealRange(range, revealType) {
      revealRangeInEditor(this.editor, TypeConverters.Range.from(range), revealType);
    } // @ts-ignore
    // setDecorations(decorationType: TextEditorDecorationType, rangesOrOptions: Range[] | DecorationOptions[]): void {
    //     throw new Error("Not implemented")
    // }

  }, {
    key: "applyEdit",
    value: function applyEdit(edit, newSelections) {
      if (!newSelections) {
        newSelections = [];
      }

      this.editor.getModel().pushEditOperations(this.editor.getSelections(), TypeConverters.WorkspaceEdit.from(edit), function () {
        return newSelections.map(function (s) {
          return TypeConverters.Selection.from(s);
        });
      });
      return Promise.resolve(null);
    }
  }, {
    key: "addAction",
    value: function addAction(param) {
      this.editor.addAction(param);
    }
  }, {
    key: "executeCommand",
    value: function executeCommand(commandId) {
      switch (commandId) {
        case 'type':
          this.editor.trigger('keyboard', commandId, arguments.length <= 1 ? undefined : arguments[1]);
          return Promise.resolve();

        case 'tab':
        case 'deleteLeft':
          this.editor.trigger('keyboard', commandId, undefined);
          return Promise.resolve();

        default:
          var action = this.editor.getAction(commandId);

          if (action) {
            if (action.isSupported()) {
              return action.run();
            }
          } else {
            new Error("unknown action id " + commandId);
          }

      }
    }
  }, {
    key: "getConfiguration",
    value: function getConfiguration(configurationId) {
      switch (configurationId) {
        case '':
          break;

        default:
          return new UndefinedConfiguration();
      }
    }
  }]);

  return TextEditor;
}();

exports.TextEditor = TextEditor;

var _initialiseProps = function _initialiseProps() {
  this._disposed = false;
};

var UndefinedConfiguration = /*#__PURE__*/function () {
  function UndefinedConfiguration() {
    _classCallCheck(this, UndefinedConfiguration);
  }

  _createClass(UndefinedConfiguration, [{
    key: "get",
    value: function get(_) {
      return undefined;
    }
  }]);

  return UndefinedConfiguration;
}();

var TextEditorEdit = /*#__PURE__*/function () {
  function TextEditorEdit(document, options) {
    _classCallCheck(this, TextEditorEdit);

    this._collectedEdits = [];
    this._setEndOfLine = undefined;
    this._finalized = false;
    this._document = document;
    this._documentVersionId = document.version;
    this._undoStopBefore = options.undoStopBefore;
    this._undoStopAfter = options.undoStopAfter;
  }

  _createClass(TextEditorEdit, [{
    key: "finalize",
    value: function finalize() {
      this._finalized = true;
      return {
        documentVersionId: this._documentVersionId,
        edits: this._collectedEdits,
        setEndOfLine: this._setEndOfLine,
        undoStopBefore: this._undoStopBefore,
        undoStopAfter: this._undoStopAfter
      };
    }
  }, {
    key: "_throwIfFinalized",
    value: function _throwIfFinalized() {
      if (this._finalized) {
        throw new Error('Edit is only valid while callback runs');
      }
    }
  }, {
    key: "replace",
    value: function replace(location, value) {
      this._throwIfFinalized();

      var range = null;

      if (location instanceof _extHostTypes.Position) {
        range = new _extHostTypes.Range(location, location);
      } else if (location instanceof _extHostTypes.Range) {
        range = location;
      } else {
        throw new Error('Unrecognized location');
      }

      this._pushEdit(range, value, false);
    }
  }, {
    key: "insert",
    value: function insert(location, value) {
      this._throwIfFinalized();

      this._pushEdit(new _extHostTypes.Range(location, location), value, true);
    }
  }, {
    key: "delete",
    value: function _delete(location) {
      this._throwIfFinalized();

      var range = null;

      if (location instanceof _extHostTypes.Range) {
        range = location;
      } else {
        throw new Error('Unrecognized location');
      }

      this._pushEdit(range, null, true);
    }
  }, {
    key: "_pushEdit",
    value: function _pushEdit(range, text, forceMoveMarkers) {
      var validRange = this._document.validateRange(range);

      this._collectedEdits.push({
        range: validRange,
        text: text,
        forceMoveMarkers: forceMoveMarkers
      });
    }
  }, {
    key: "setEndOfLine",
    value: function setEndOfLine(endOfLine) {
      this._throwIfFinalized();

      if (endOfLine !== _extHostTypes.EndOfLine.LF && endOfLine !== _extHostTypes.EndOfLine.CRLF) {
        throw new Error('Illegal argument endOfLine');
      }

      this._setEndOfLine = endOfLine;
    }
  }]);

  return TextEditorEdit;
}();

exports.TextEditorEdit = TextEditorEdit;