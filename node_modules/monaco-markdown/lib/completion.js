'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.activateCompletion = activateCompletion;

var TypeConverters = _interopRequireWildcard(require("./vscode-converters"));

var _monacoEditor = require("monaco-editor");

var _vscodeMonaco = require("./vscode-monaco");

var _extHostTypes = require("./extHostTypes");

var _util = require("./util");

var _toc = require("./toc");

var latex = _interopRequireWildcard(require("./latex"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var completionActivated = false;

function activateCompletion(editor) {
  if (!completionActivated) {
    //TODO: remove provider when context is disposed
    var provider = new MdCompletionItemProvider();

    _monacoEditor.languages.registerCompletionItemProvider(editor.languageId, provider);

    completionActivated = true;
  }
}

function completionList(items) {
  return {
    suggestions: items.map(function (v, _) {
      return Object.assign({}, v);
    })
  };
}

function newCompletionItem(text, kind) {
  return {
    label: text,
    kind: kind,
    additionalTextEdits: undefined,
    command: undefined,
    commitCharacters: undefined,
    detail: undefined,
    documentation: undefined,
    filterText: undefined,
    insertTextRules: undefined,
    preselect: false,
    range: undefined,
    sortText: undefined,
    insertText: undefined
  };
}

var MdCompletionItemProvider = /*#__PURE__*/function () {
  // Suffixes explained:
  // \cmd         -> 0
  // \cmd{$1}     -> 1
  // \cmd{$1}{$2} -> 2
  //
  // Use linebreak to mimic the structure of the KaTeX [Support Table](https://katex.org/docs/supported.html)
  function MdCompletionItemProvider() {
    _classCallCheck(this, MdCompletionItemProvider);

    this.triggerCharacters = ['(', '\\', '/', '[', '#'];

    // \cmd
    var c1 = latex._c1.map(function (cmd) {
      var item = newCompletionItem('\\' + cmd, _monacoEditor.languages.CompletionItemKind.Function);
      item.insertText = cmd;
      return item;
    }); // \cmd{$1}


    var c2 = latex._c2.map(function (cmd) {
      var item = newCompletionItem('\\' + cmd, _monacoEditor.languages.CompletionItemKind.Function);
      item.insertText = new _extHostTypes.SnippetString("".concat(cmd, "{$1}")).value;
      item.insertTextRules = _monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet;
      return item;
    }); // \cmd{$1}{$2}


    var c3 = latex._c3.map(function (cmd) {
      var item = newCompletionItem('\\' + cmd, _monacoEditor.languages.CompletionItemKind.Function);
      item.insertText = new _extHostTypes.SnippetString("".concat(cmd, "{$1}{$2}")).value;
      item.insertTextRules = _monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet;
      return item;
    });

    var envSnippet = newCompletionItem('\\begin', _monacoEditor.languages.CompletionItemKind.Snippet);
    envSnippet.insertText = new _extHostTypes.SnippetString('begin{${1|aligned,alignedat,array,bmatrix,Bmatrix,cases,darray,dcases,gathered,matrix,pmatrix,vmatrix,Vmatrix|}}\n\t$2\n\\end{$1}').value;
    envSnippet.insertTextRules = _monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet;
    this.mathCompletions = [].concat(_toConsumableArray(c1), _toConsumableArray(c2), _toConsumableArray(c3), [envSnippet]); // Sort

    this.mathCompletions.forEach(function (item) {
      item.sortText = (typeof item.label === 'string' ? item.label : item.label.label).replace(/[a-zA-Z]/g, function (c) {
        if (/[a-z]/.test(c)) {
          return "0".concat(c);
        } else {
          return "1".concat(c.toLowerCase());
        }
      });
    });
  }

  _createClass(MdCompletionItemProvider, [{
    key: "provideCompletionItems",
    value: function provideCompletionItems(model, _position, _context, _token) {
      var document = new _vscodeMonaco.TextDocument(model);
      var position = TypeConverters.Position.to(_position);
      var lineTextBefore = document.lineAt(position.line).text.substring(0, position.character);
      var lineTextAfter = document.lineAt(position.line).text.substring(position.character);
      var matches;

      if ((matches = lineTextBefore.match(/\\[^$]*$/)) !== null) {
        /* ┌────────────────┐
           │ Math functions │
           └────────────────┘ */
        if (/(^|[^\$])\$(|[^ \$].*)\\\w*$/.test(lineTextBefore) && lineTextAfter.includes('$')) {
          // Complete math functions (inline math)
          return completionList(this.mathCompletions);
        } else {
          var textBefore = document.getText(new _extHostTypes.Range(new _extHostTypes.Position(0, 0), position));
          var textAfter = document.getText().substr(document.offsetAt(position));

          if ((matches = textBefore.match(/\$\$/g)) !== null && matches.length % 2 !== 0 && textAfter.includes('\$\$')) {
            // Complete math functions ($$ ... $$)
            return completionList(this.mathCompletions);
          } else {
            return completionList([]);
          }
        }
      } else if (/\[[^\]]*?\]\[[^\]]*$/.test(lineTextBefore)) {
        /* ┌───────────────────────┐
           │ Reference link labels │
           └───────────────────────┘ */
        var startIndex = lineTextBefore.lastIndexOf('[');
        var range = new _extHostTypes.Range(position.with({
          character: startIndex + 1
        }), position);
        return new Promise(function (res, _) {
          var lines = document.getText().split(/\r?\n/);
          var usageCounts = lines.reduce(function (useCounts, currentLine) {
            var match;
            var pattern = /\[[^\]]+\]\[([^\]]*?)\]/g;

            while ((match = pattern.exec(currentLine)) !== null) {
              var usedRef = match[1];

              if (!useCounts.has(usedRef)) {
                useCounts.set(usedRef, 0);
              }

              useCounts.set(usedRef, useCounts.get(usedRef) + 1);
            }

            return useCounts;
          }, new Map());
          var refLabels = lines.reduce(function (prev, curr) {
            var match;

            if ((match = /^\[([^\]]*?)\]: (\S*)( .*)?/.exec(curr)) !== null) {
              var ref = match[1];
              var item = newCompletionItem(ref, _monacoEditor.languages.CompletionItemKind.Reference);
              var usages = usageCounts.get(ref) || 0;
              item.insertText = ref;
              item.documentation = {
                value: match[2]
              };
              item.detail = usages === 1 ? "1 usage" : "".concat(usages, " usages"); // Prefer unused items

              item.sortText = usages === 0 ? "0-".concat(ref) : item.sortText = "1-".concat(ref);
              item.range = TypeConverters.Range.from(range);
              prev.push(item);
            }

            return prev;
          }, []);
          res(completionList(refLabels));
        });
      } else if (/\[[^\]]*\]\(#[^\)]*$/.test(lineTextBefore)) {
        /* ┌───────────────────────────┐
           │ Anchor tags from headings │
           └───────────────────────────┘ */
        var _startIndex = lineTextBefore.lastIndexOf('(');

        var endPosition = position;
        var addClosingParen = false;

        if (/^([^\) ]+\s*|^\s*)\)/.test(lineTextAfter)) {
          // try to detect if user wants to replace a link (i.e. matching closing paren and )
          // Either: ... <CURSOR> something <whitespace> )
          //     or: ... <CURSOR> <whitespace> )
          //     or: ... <CURSOR> )     (endPosition assignment is a no-op for this case)
          // in every case, we want to remove all characters after the cursor and before that first closing paren
          endPosition = position.with({
            character: +endPosition.character + lineTextAfter.indexOf(')')
          });
        } else {
          // If no closing paren is found, replace all trailing non-white-space chars and add a closing paren
          // distance to first non-whitespace or EOL
          var toReplace = 0;

          while (toReplace < lineTextAfter.length && ' \t\n\r\v'.indexOf(lineTextAfter.charAt(toReplace)) != -1) {
            toReplace++;
          }

          endPosition = position.with({
            character: +endPosition.character + toReplace
          });
          addClosingParen = true;
        }

        var _range = new _extHostTypes.Range(position.with({
          character: _startIndex + 1
        }), endPosition);

        return new Promise(function (res, _) {
          var toc = (0, _toc.buildToc)(document);
          var headingCompletions = toc.reduce(function (prev, curr) {
            var item = newCompletionItem('#' + (0, _util.slugify)(curr.text), _monacoEditor.languages.CompletionItemKind.Reference);
            var label = typeof item.label === 'string' ? item.label : item.label.label;

            if (addClosingParen) {
              item.insertText = label + ')';
            } else {
              item.insertText = label;
            }

            item.documentation = curr.text;
            item.range = TypeConverters.Range.from(_range);
            prev.push(item);
            return prev;
          }, []);
          res(completionList(headingCompletions));
        });
      } else {
        return completionList([]);
      }
    }
  }]);

  return MdCompletionItemProvider;
}();